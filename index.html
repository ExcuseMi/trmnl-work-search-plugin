{% liquid 
assign difficulty = trmnl.plugin_settings.custom_fields_values.difficulty | default: "easy"
assign word_items = data
assign theme = "Unknown"
assign word_list = ""
assign word_count = 8
for word_item in word_items
assign word = word_item.word
if forloop.first
assign word_list = word
else
assign word_list = word_list | append: ", " | append: word
endif
endfor
%}
<style>
  :root {
    --grid-size: {{ grid_size | default: 12 }};
    --cell-size: calc(100% / var(--grid-size));
  }

  #puzzle-grid {
    table-layout: fixed;
    border-collapse: collapse;
  }

  #puzzle-grid tr td {
    width: var(--cell-size);
    height: var(--cell-size);
    font-size: clamp(6px, calc(70vw / var(--grid-size)), 24px);
    font-weight: calc(400 + (var(--grid-size) * 15));   
    line-height: 1;
    text-align: center;
    vertical-align: middle;
    box-sizing: border-box;
    font-family: var(--label-font-family);
  }

  .puzzle {
    border: solid 1px black;
    box-sizing: border-box;
    border-radius: 8px;
    max-width: 65%;
    aspect-ratio: 1;
  }
</style>

<div class="layout layout--stretch">
  <div class="flex flex--row flex--center-y flex--evenly stretch">
    <div class="puzzle stretch h--full">
      <table id="puzzle-grid" class="text--center h--full"></table>
    </div>
    <div class="flex flex--col" id="sidebar">
      {% if difficulty == "easy" %}
      <div class="word-list">
        <div class="label">FIND THESE WORDS:</div>
        <div class="columns">
          <div id="word-list" class="column gap--xsmall" data-overflow-max-cols="2">
          </div>
        </div>
      </div>
      {% else %}
      <div class="word-list">
        <div class="label">{{ word_count }} WORDS HIDDEN</div>
      </div>
      {% endif %}

      <div class="label">SCAN FOR SOLUTION</div>
      <div id="qrcode-container" class="bg--white p--1 mb--2 mr--2">
        <!-- QR code will be inserted here by JS -->
      </div>
    </div>
  </div>
</div>

<div class="title_bar">
  <span class="title">Word Search</span>
  <span class="instance">{{theme}}</span>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js" integrity="sha512-CNgIRecGo7nphbeZ04Sc13ka07paqdeTu0WR1IM4kNcpmBAUSHSQX0FslNhTDadL4O5SAGapGt4FodqL8My0mA==" crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
<script src="https://cdn.jsdelivr.net/gh/yunruse/trmnl-tricks/QR.js" defer></script>

<script>
  // Configuration from plugin settings
  const config = {
    gridSize: {{ grid_size | default: 12 }},
    wordCount: {{ word_count | default: 8 }},
    difficulty: "{{ difficulty | default: 'easy' }}",
    theme: "{{ theme }}".trim() || null,
    wordList: "{{ word_list }}"
  };

  // Seeded random number generator (Mulberry32)
  function seededRandom(seed) {
    return function() {
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  class WordSearchPuzzle {
    constructor(config) {
      this.config = config;
      this.grid = [];
      this.words = [];
      this.solution = [];
      this.theme = config.theme || "Custom Words";
      this.seed = Date.now();
      this.random = seededRandom(this.seed);
    }

    init() {
      console.log('=== WORD SEARCH PUZZLE GENERATOR ===');
      console.log('Theme:', this.theme);
      console.log('Grid Size:', this.config.gridSize);
      console.log('Difficulty:', this.config.difficulty);

      // Initialize empty grid
      this.grid = Array(this.config.gridSize).fill(null)
        .map(() => Array(this.config.gridSize).fill(''));

      // Parse words from wordList
      this.parseWordList();

      // Place words on grid
      this.placeWords();

      // Fill empty spaces
      this.fillGrid();

      // Render
      this.render();

      // Log solution
      this.logSolution();
    }

    parseWordList() {
      // Split the comma-separated word list
      const wordArray = this.config.wordList.split(',').map(w => w.trim().toUpperCase());

      // Filter words to fit grid
      const minLen = 4;
      const maxLen = Math.min(10, this.config.gridSize - 1);

      this.words = wordArray
        .filter(w => w.length >= minLen && w.length <= maxLen && /^[A-Z]+$/.test(w))
        .slice(0, this.config.wordCount);

      // If we don't have enough words from the list, add fallback words
      if (this.words.length < this.config.wordCount) {
        console.warn('Not enough valid words from list. Adding fallback words.');
        const fallbackWords = ['PUZZLE', 'SEARCH', 'FIND', 'WORD', 'GAME', 'FUN', 'BRAIN', 'SOLVE'];
        for (let i = this.words.length; i < this.config.wordCount; i++) {
          if (fallbackWords[i - this.words.length]) {
            this.words.push(fallbackWords[i - this.words.length]);
          }
        }
      }

      console.log('Using words:', this.words);
    }

    placeWords() {
      // Directions: horizontal, vertical, diagonal (8 directions)
      const directions = [
        [0, 1],   // right
        [1, 0],   // down
        [1, 1],   // diagonal down-right
        [-1, 1],  // diagonal up-right
        [0, -1],  // left
        [-1, 0],  // up
        [-1, -1], // diagonal up-left
        [1, -1]   // diagonal down-left
      ];

      for (const word of this.words) {
        let placed = false;
        let attempts = 0;
        const maxAttempts = 100;

        while (!placed && attempts < maxAttempts) {
          const row = Math.floor(Math.random() * this.config.gridSize);
          const col = Math.floor(Math.random() * this.config.gridSize);
          const [dy, dx] = directions[Math.floor(Math.random() * directions.length)];

          if (this.canPlaceWord(word, row, col, dy, dx)) {
            this.placeWord(word, row, col, dy, dx);
            placed = true;
          }
          attempts++;
        }

        if (!placed) {
          console.warn('Could not place word:', word);
        }
      }
    }

    canPlaceWord(word, row, col, dy, dx) {
      const endRow = row + (word.length - 1) * dy;
      const endCol = col + (word.length - 1) * dx;

      if (endRow < 0 || endRow >= this.config.gridSize) return false;
      if (endCol < 0 || endCol >= this.config.gridSize) return false;

      for (let i = 0; i < word.length; i++) {
        const r = row + i * dy;
        const c = col + i * dx;
        if (this.grid[r][c] !== '' && this.grid[r][c] !== word[i]) {
          return false;
        }
      }

      return true;
    }

    placeWord(word, row, col, dy, dx) {
      const positions = [];
      for (let i = 0; i < word.length; i++) {
        const r = row + i * dy;
        const c = col + i * dx;
        this.grid[r][c] = word[i];
        positions.push([r, c]);
      }

      this.solution.push({
        word: word,
        start: [row, col],
        end: [row + (word.length - 1) * dy, col + (word.length - 1) * dx],
        direction: [dy, dx],
        positions: positions
      });
    }

    fillGrid() {
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      for (let r = 0; r < this.config.gridSize; r++) {
        for (let c = 0; c < this.config.gridSize; c++) {
          if (this.grid[r][c] === '') {
            this.grid[r][c] = letters[Math.floor(this.random() * letters.length)];
          }
        }
      }
    }

    render() {
      // Render grid
      const table = document.getElementById('puzzle-grid');
      table.innerHTML = '';

      for (let r = 0; r < this.config.gridSize; r++) {
        const tr = document.createElement('tr');
        for (let c = 0; c < this.config.gridSize; c++) {
          const td = document.createElement('td');
          td.textContent = this.grid[r][c];
          td.className = "";
          td.style.display = "table-cell";
          tr.appendChild(td);
        }
        table.appendChild(tr);
      }

      // Render word list (only in easy mode)
      if (this.config.difficulty === 'easy') {
        const wordList = document.getElementById('word-list');
        wordList.innerHTML = '';
        this.words.forEach(word => {
          // Create the item container
          const itemDiv = document.createElement('div');
          itemDiv.className = 'item';

          // Create the content container
          const contentDiv = document.createElement('div');
          contentDiv.className = 'content';

          // Create the description span
          const span = document.createElement('span');
          span.className = 'label label--large';
          span.textContent = word;
          
          // Assemble the structure
          contentDiv.appendChild(span);
          itemDiv.appendChild(contentDiv);
          wordList.appendChild(itemDiv);
        });
      }

      // Generate QR code solution URL
      this.generateQR();
    }

    generateQR() {
      // Generate seed from timestamp for reproducible random generation
      const seed = Date.now();
      
      // ULTRA-COMPACT STRING FORMAT: "pos;dir;len,pos;dir;len,..."
      // pos = row*gridSize + col (single number)
      // dir = 0-7 (8 directions as single digit)
      // len = word length (single/double digit)
      const dirMap = {
        '0,1': 0,   // right
        '1,0': 1,   // down
        '1,1': 2,   // diagonal down-right
        '-1,1': 3,  // diagonal up-right
        '0,-1': 4,  // left
        '-1,0': 5,  // up
        '-1,-1': 6, // diagonal up-left
        '1,-1': 7   // diagonal down-left
      };
      
      const encodedSolution = this.solution.map(s => {
        const pos = s.start[0] * this.config.gridSize + s.start[1];
        const dir = dirMap[s.direction.join(',')];
        const len = s.word.length;
        return `${pos};${dir};${len}`;
      }).join(',');
      
      // Compact format: theme|words|solution|gridSize|seed
      const compactStr = `${this.theme}|${this.words.join(',')}|${encodedSolution}|${this.config.gridSize}|${seed}`;
      const encoded = btoa(compactStr);
      const solutionUrl = `https://excusemi.github.io/trmnl-word-search-plugin/?p=${encoded}`;

      console.log('Solution URL:', solutionUrl);
      console.log('URL Length:', solutionUrl.length, 'characters');
      console.log('Payload size:', encoded.length, 'bytes');
      console.log('Compact string:', compactStr.substring(0, 100) + '...');
      console.log('Random seed:', seed);
      
      // Store URL and generate QR code after delay
      this.solutionUrl = solutionUrl;
      setTimeout(() => this.createQRCode(), 500);
    }
    
    createQRCode() {
      const qrContainer = document.getElementById('qrcode-container');
      
      if (!qrContainer) {
        console.error('QR container not found');
        return;
      }
      
      if (typeof QRCode === 'undefined') {
        console.warn('QRCode library not ready, retrying...');
        setTimeout(() => this.createQRCode(), 500);
        return;
      }
      
      try {
        // Clear container
        qrContainer.innerHTML = '';
        
        // Create wrapper div
        const wrapper = document.createElement('div');
        wrapper.style.display = 'inline-block';
        wrapper.style.padding = '8px';
        wrapper.style.background = 'white';
        qrContainer.appendChild(wrapper);
        
        // Generate QR code
        const qr = new QRCode(wrapper, {
          text: this.solutionUrl,
          width: 128,
          height: 128,
          colorDark: '#000000',
          colorLight: '#ffffff',
          correctLevel: QRCode.CorrectLevel.L
        });
        
        console.log('QR code generated successfully');
        
        // Style for e-ink after image loads
        setTimeout(() => {
          const img = wrapper.querySelector('img');
          if (img) {
            img.style.imageRendering = 'pixelated';
            img.style.display = 'block';
            console.log('QR code image styled');
          } else {
            console.error('QR code img element not found');
          }
        }, 200);
        
      } catch (error) {
        console.error('Error generating QR code:', error);
      }
    }

    logSolution() {
      console.log('\n=== SOLUTION ===');
      this.solution.forEach(s => {
        console.log(`${s.word}: Start[${s.start}] â†’ End[${s.end}] Direction[${s.direction}]`);
        console.log('  Positions:', s.positions.map(p => `[${p}]`).join(' '));
      });
      console.log('\nAll words placed:', this.words.join(', '));
    }
  }

  // Initialize puzzle when page loads
  window.addEventListener('DOMContentLoaded', () => {
    const puzzle = new WordSearchPuzzle(config);
    puzzle.init();
  });
</script>
