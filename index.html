<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Word Search Solution</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Courier New', monospace;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    .container {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      padding: 30px;
      max-width: 800px;
      width: 100%;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    h1 {
      font-size: 32px;
      color: #333;
      margin-bottom: 10px;
    }
    
    .theme {
      font-size: 18px;
      color: #666;
      font-style: italic;
      margin-bottom: 20px;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 25px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn-reveal-all {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-reset {
      background: #f5f5f5;
      color: #333;
      border: 2px solid #ddd;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }

    .btn:active {
      transform: translateY(0);
    }

    .grid-container {
      display: flex;
      justify-content: center;
      margin-bottom: 30px;
    }

    table {
      border-collapse: collapse;
    }

    td {
      width: 35px;
      height: 35px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
      border: 1px solid #ddd;
      position: relative;
      transition: all 0.3s ease;
      background-color: white;
    }

    td.revealed {
      color: white;
      font-weight: 900;
      transform: scale(1.1);
      z-index: 10;
      border-color: rgba(0,0,0,0.3);
    }

    .word-legend {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 20px;
    }

    .word-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 15px;
      background: #f5f5f5;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;
      user-select: none;
    }

    .word-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 3px 10px rgba(0,0,0,0.1);
    }

    .word-item.found {
      opacity: 0.7;
      text-decoration: line-through;
    }

    .color-box {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 2px solid rgba(0,0,0,0.2);
    }

    .error {
      text-align: center;
      padding: 40px;
      color: #e74c3c;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .stats {
      text-align: center;
      margin-top: 20px;
      font-size: 16px;
      color: #666;
      font-weight: bold;
    }

    @media (max-width: 600px) {
      .container {
        padding: 15px;
      }

      h1 {
        font-size: 24px;
      }

      td {
        width: 25px;
        height: 25px;
        font-size: 14px;
      }

      .word-item {
        font-size: 12px;
        padding: 6px 10px;
      }

      .btn {
        padding: 8px 16px;
        font-size: 14px;
      }

      .word-legend {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üîç Word Search Solution</h1>
      <div class="theme" id="theme-display"></div>

      <div class="controls">
        <button class="btn btn-reveal-all" onclick="revealAllWords()">Reveal All Words</button>
        <button class="btn btn-reset" onclick="resetAllWords()">Reset All</button>
      </div>
    </div>

    <div id="content">
      <div class="loading">Loading puzzle...</div>
    </div>

    <div class="stats" id="stats-display"></div>
  </div>

  <script>
    // Color palette for highlighting words
    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
      '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52B788',
      '#FF8C94', '#A8DADC', '#F4A261', '#E76F51', '#2A9D8F'
    ];

    const GITHUB_REPO = 'https://raw.githubusercontent.com/ExcuseMi/trmnl-word-search-plugin/main';

    // Global variables
    let puzzleData = null;
    let revealedWords = new Set();

    async function loadPuzzle(puzzleId) {
      try {
        // Parse the ID format: "10-easy-1" or "10-easy-123"
        const [size, difficulty, fileNumber] = puzzleId.split('-');

        // Validate the parts
        if (!size || !difficulty || !fileNumber) {
          throw new Error(`Invalid puzzle ID format: ${puzzleId}. Expected format: "size-difficulty-filenumber" (e.g., "10-easy-1")`);
        }

        // Convert fileNumber to integer for basic validation
        const fileNum = parseInt(fileNumber);
        if (isNaN(fileNum) || fileNum < 1) {
          throw new Error(`Invalid file number in puzzle ID: ${puzzleId}`);
        }

        // Construct the file path (no zero-padding)
        const puzzleFile = `${GITHUB_REPO}/data/${size}/${difficulty}/${fileNumber}.json`;

        // Fetch puzzle
        const puzzleResponse = await fetch(puzzleFile);
        if (!puzzleResponse.ok) {
          throw new Error(`Failed to load puzzle file: ${puzzleFile}`);
        }

        const puzzle = await puzzleResponse.json();

        // Convert grid string to 2D array
        const grid = [];
        for (let r = 0; r < puzzle.gridSize; r++) {
          const row = [];
          for (let c = 0; c < puzzle.gridSize; c++) {
            row.push(puzzle.grid[r * puzzle.gridSize + c]);
          }
          grid.push(row);
        }

        // Parse solution with new format: "pos;dir_idx;length;word"
        const dirMap = [[0,1], [1,0], [1,1], [-1,1], [0,-1], [-1,0], [-1,-1], [1,-1]];
        const solutionParts = puzzle.solution.split(',');
        const solution = solutionParts.map(part => {
          const parts = part.split(';');

          // Handle both old format (3 parts) and new format (4 parts)
          let pos, dir, length, word;

          if (parts.length === 3) {
            // Old format: pos;dir;length
            [pos, dir, length] = parts.map(Number);
            // Reconstruct word from grid (may be backwards)
            const startRow = Math.floor(pos / puzzle.gridSize);
            const startCol = pos % puzzle.gridSize;
            const [dy, dx] = dirMap[dir];
            word = '';
            const positions = [];
            for (let i = 0; i < length; i++) {
              const r = startRow + i * dy;
              const c = startCol + i * dx;
              positions.push([r, c]);
              word += grid[r][c];
            }
            return { word, positions };
          } else if (parts.length === 4) {
            // New format: pos;dir;length;word
            [pos, dir, length, word] = parts;
            pos = Number(pos);
            dir = Number(dir);
            length = Number(length);

            const startRow = Math.floor(pos / puzzle.gridSize);
            const startCol = pos % puzzle.gridSize;
            const [dy, dx] = dirMap[dir];

            const positions = [];
            for (let i = 0; i < length; i++) {
              const r = startRow + i * dy;
              const c = startCol + i * dx;
              positions.push([r, c]);
            }
            return { word, positions };
          } else {
            throw new Error(`Invalid solution format: ${part}`);
          }
        });

        // Get words in the same order as wordlist from the puzzle
        const wordlist = puzzle.wordlist || [];
        const solutionMap = {};

        // Create a map of word to solution entry
        solution.forEach(sol => {
          solutionMap[sol.word] = sol;
        });

        // Reorder solution to match wordlist order
        const orderedSolution = [];
        const orderedWords = [];

        wordlist.forEach(word => {
          if (solutionMap[word]) {
            orderedSolution.push(solutionMap[word]);
            orderedWords.push(word);
          }
        });

        // If wordlist is empty or doesn't match, fall back to solution order
        const finalSolution = orderedSolution.length > 0 ? orderedSolution : solution;
        const finalWords = orderedWords.length > 0 ? orderedWords : solution.map(s => s.word);

        puzzleData = {
          theme: puzzle.theme,
          grid: grid,
          words: finalWords,
          solution: finalSolution,
          gridSize: puzzle.gridSize
        };

        renderPuzzle();

      } catch (e) {
        console.error('Failed to load puzzle:', e);
        showError(`Failed to load puzzle: ${e.message}`);
      }
    }

    function renderPuzzle() {
      const { theme, grid, words, solution, gridSize } = puzzleData;

      // Update theme
      document.getElementById('theme-display').textContent =
        `Theme: ${theme.charAt(0).toUpperCase() + theme.slice(1)}`;

      // Build grid HTML
      let html = '<div class="grid-container"><table id="puzzle-grid">';

      for (let r = 0; r < gridSize; r++) {
        html += '<tr>';
        for (let c = 0; c < gridSize; c++) {
          const letter = grid[r][c];
          html += `<td data-row="${r}" data-col="${c}">${letter}</td>`;
        }
        html += '</tr>';
      }

      html += '</table></div>';

      // Add word legend in 2-column grid, using words array order
      html += '<div class="word-legend" id="word-legend">';
      words.forEach((word, idx) => {
        const color = colors[idx % colors.length];
        html += `
          <div class="word-item" data-word-index="${idx}" onclick="revealWord(${idx})">
            <div class="color-box" style="background: ${color}"></div>
            <span>${word}</span>
          </div>
        `;
      });
      html += '</div>';

      document.getElementById('content').innerHTML = html;

      // Initialize stats
      updateStats();
    }

    function revealWord(wordIndex) {
      if (!puzzleData || revealedWords.has(wordIndex)) return;

      const sol = puzzleData.solution[wordIndex];
      const color = colors[wordIndex % colors.length];

      // Highlight cells
      sol.positions.forEach((pos, posIdx) => {
        const [r, c] = pos;
        const cell = document.querySelector(`td[data-row="${r}"][data-col="${c}"]`);

        if (cell) {
          setTimeout(() => {
            cell.classList.add('revealed');
            cell.style.backgroundColor = color;
          }, posIdx * 30);
        }
      });

      // Mark word as found
      revealedWords.add(wordIndex);
      const wordItem = document.querySelector(`.word-item[data-word-index="${wordIndex}"]`);
      if (wordItem) {
        wordItem.classList.add('found');
      }

      updateStats();
    }

    function revealAllWords() {
      if (!puzzleData) return;

      // Clear all existing highlights first
      document.querySelectorAll('td.revealed').forEach(cell => {
        cell.classList.remove('revealed');
        cell.style.backgroundColor = '';
      });

      // Reveal all words with staggered animation
      puzzleData.solution.forEach((sol, wordIndex) => {
        const color = colors[wordIndex % colors.length];

        sol.positions.forEach((pos, posIdx) => {
          const [r, c] = pos;
          const cell = document.querySelector(`td[data-row="${r}"][data-col="${c}"]`);

          if (cell) {
            setTimeout(() => {
              cell.classList.add('revealed');
              cell.style.backgroundColor = color;
            }, (wordIndex * 100) + (posIdx * 20));
          }
        });

        // Mark word as found
        revealedWords.add(wordIndex);
        const wordItem = document.querySelector(`.word-item[data-word-index="${wordIndex}"]`);
        if (wordItem) {
          wordItem.classList.add('found');
        }
      });

      updateStats();
    }

    function resetAllWords() {
      // Clear all highlights
      document.querySelectorAll('td.revealed').forEach(cell => {
        cell.classList.remove('revealed');
        cell.style.backgroundColor = '';
      });

      // Reset word items
      document.querySelectorAll('.word-item.found').forEach(item => {
        item.classList.remove('found');
      });

      // Clear revealed words set
      revealedWords.clear();

      updateStats();
    }

    function updateStats() {
      const totalWords = puzzleData ? puzzleData.words.length : 0;
      const foundWords = revealedWords.size;
      const percentage = totalWords > 0 ? Math.round((foundWords / totalWords) * 100) : 0;

      document.getElementById('stats-display').innerHTML = `
        Found: <span style="color: #667eea">${foundWords}</span> / ${totalWords} words (${percentage}%)
      `;
    }

    function showError(message) {
      document.getElementById('content').innerHTML = `
        <div class="error">
          <h2>‚ùå Error</h2>
          <p>${message}</p>
        </div>
      `;
      document.getElementById('stats-display').innerHTML = '';
    }

    // Main initialization
    window.addEventListener('DOMContentLoaded', () => {
      // Get URL parameter
      const urlParams = new URLSearchParams(window.location.search);
      const puzzleId = urlParams.get('id');

      if (!puzzleId) {
        showError('No puzzle ID found in URL. Please scan a valid QR code.');
        return;
      }
      
      // Load and render puzzle
      loadPuzzle(puzzleId);
    });
  </script>
</body>
</html>